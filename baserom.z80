;Stack: $FFF0
;

org $0000
_reset:;reset vector
	;We don't want any peripherals messing with stuff.
	di;1 byte
	;Check if [?] key is held down. If so, enter diagnostics/selftest "mode".
	in a,($0b);2
	and %00111111;2
	jr _init;2 bytes
	nop
_rst_08:
	jp $E008;3
	nop;1
	nop;1
	nop;1
	nop;1
	nop;1
_rst_10:
	jp $E010;3
	nop;1
	nop;1
	nop;1
	nop;1
	nop;1
_rst_18:
	jp $E018;3
	nop;1
	nop;1
	nop;1
	nop;1
	nop;1
_rst_20:
	jp $E020;3
	nop;1
	nop;1
	nop;1
	nop;1
	nop;1
_rst_28:
	jp $E028;3
	nop;1
	nop;1
	nop;1
	nop;1
	nop;1
_rst_30:
	jp $E030;3
	nop;1
	nop;1
	nop;1
	nop;1
	nop;1
_rst_38:
	jp $E038;3
	nop;1
	nop;1
	nop;1
	nop;1
	nop;1
_init:
	cp %00101111;[?];2
	jp z,_diagnostics
	;Check if base of cartridge rom ($2000) contains the magic number. But, if [CE] is held down, don't autoboot.
	in a,($0B)
	and %00111111
	cp %00111101
	jr z,_init0
	ld ix,_cart_header
	ld iy,$2000
	ld a,(ix+0)
	cp (iy+0)
	jp nz,_init0
	ld a,(ix+1)
	cp (iy+1)
	jp nz,_init0
	ld a,(ix+2)
	cp (iy+2)
	jp nz,_init0
	ld a,(ix+3)
	cp (iy+3)
	jp z,$2004

_init0:
	ld sp,$FFF0;Set stack pointer to top of base RAM.
	exx
	ld hl,$0000;Initial monitor address
	ld bc,0;Input buffer
	ld d,0;Input buffer offset
	exx
	ld iy,$FFF1
_main:
	;Print current address to left hand side of the screen.
	exx
	push hl
	exx
	pop de
	ld a,d
	call _gadget1
	ld (iy+0),a
	ld a,d
	call _gadget2
	ld (iy+1),a
	ld a,e
	call _gadget1
	ld (iy+2),a
	ld a,e
	call _gadget2
	or %00000001;Add the decimal point as a "divider" of sorts.
	ld (iy+3),a
;Obtain current input buffer offset. If zero, print value of current memory address. If not, print the input buffer.
	exx
	push de
	exx
	pop de
	ld a,d
	cp 0
	jp nz,_print_buffer
	ld a,0
	ld (iy+4),a
	ld (iy+5),a
	exx
	push hl
	exx
	pop de
	ld a,(de)
	call _gadget1
	ld (iy+6),a
	ld a,(de)
	call _gadget2
	ld (iy+7),a
_keypad_scan:
	call _draw_screen
	in a,($08)
	and %00111111
	cp %00011111
	jp z,_type0;[0]
	cp %00101111
	jp z,_type1;[1]
	cp %00110111;[4]
	jp z,_type4
	cp %00111011;[7]
	jp z,_type7
	cp %00111101;[A]
	jp z,_typeA
	cp %00111110;[D]
	jp z,_typeD

	call _draw_screen
	in a,($09)
	and %00111111
	cp %00011111;[A-]
	jp z,_addr_dec;
	cp %00101111;[2]
	jp z,_type2
	cp %00110111;[5]
	jp z,_type5
	cp %00111011;[8]
	jp z,_type8
	cp %00111101;[B]
	jp z,_typeB
	cp %00111110;[E]
	jp z,_typeE

	call _draw_screen
	in a,($0A)
	and %00111111
	cp %00011111;[A+]
	jp z,_addr_inc;
	cp %00101111;[3]
	jp z,_type3
	cp %00110111;[6]
	jp z,_type6
	cp %00111011;[9]
	jp z,_type9
	cp %00111101;[C]
	jp z,_typeC
	cp %00111110;[F]
	jp z,_typeF

	call _draw_screen
	in a,($0B)
	and %00111111
	cp %00011111;[GO]
	jp z,_go;
	cp %00101111;[?]
	jp z,_user_defined
	cp %00110111;[WR]
	jp z,_write_value
	cp %00111011;[RD]
	jp z,_set_addr
	cp %00111101;[CE]
	jp z,_clear_input
	cp %00111110;[OFF]
	jp z,_off
	jp _main

_draw_screen:;By using a frame buffer, we (well I) simplifies the screen drawing process. Also allows drawing the screen more often (and thus making it BRIGHTER) much easier.
	ld ix,$FFF1
	ld a,(ix+0)
	out ($00),a
	ld a,(ix+1)
	out ($01),a
	ld a,(ix+2)
	out ($02),a
	ld a,(ix+3)
	out ($03),a
	ld a,(ix+4)
	out ($04),a
	ld a,(ix+5)
	out ($05),a
	ld a,(ix+6)
	out ($06),a
	ld a,(ix+7)
	out ($07),a
	ret

_type_value: 
     EXX
     PUSH BC;Input buffer
     PUSH DE;Buffer index
     EXX
     POP DE
     POP BC
     LD E,A
     LD A,D
     CP $00
     JR Z,BUFFER_FIRST_POS
     CP $01
     JR Z,BUFFER_SECOND_POS
     CP $02
     JR Z,BUFFER_THIRD_POS
     CP $03
     JR Z,BUFFER_FOURTH_POS
     RET
BUFFER_FIRST_POS:
     LD A,B
     call _gadget3
     LD B,A
     PUSH BC
     LD D,$01
     JR TYPE_NUMBER_END
BUFFER_SECOND_POS:
     LD A,B
     AND $f0
     OR E
     LD B,A
     PUSH BC
     LD D,$02
     JR TYPE_NUMBER_END
BUFFER_THIRD_POS:
     LD A,C
     call _gadget3
     LD C,A
     PUSH BC
     LD D,$03
     JR TYPE_NUMBER_END
BUFFER_FOURTH_POS:
     LD A,C
     AND $f0
     OR E
     LD C,A
     PUSH BC
     LD D,$04
TYPE_NUMBER_END:
     PUSH DE
     EXX
     POP DE
     POP BC
     EXX
     RET

_gadget3:
	AND $0f
	SLA E
	SLA E
	SLA E
	SLA E
	OR E
	ret

_type0:
	ld a,0
	jr _gadget0
_type1:
	ld a,1
	jr _gadget0
_type2:
	ld a,2
	jr _gadget0
_type3:
	ld a,$03
	jr _gadget0
_type4:
	ld a,$04
	jr _gadget0
_type5:
	ld a,$05
	jr _gadget0
_type6:
	ld a,$06
	jr _gadget0
_type7:
	ld a,$07
	jr _gadget0
_type8:
	ld a,$08
	jr _gadget0
_type9:
	ld a,$09
	jr _gadget0
_typeA:
	ld a,$0a
	jr _gadget0
_typeB:
	ld a,$0b
	jr _gadget0
_typeC:
	ld a,$0c
	jr _gadget0
_typeD:
	ld a,$0d
	jr _gadget0
_typeE:
	ld a,$0e
	jr _gadget0
_typeF:
	ld a,$0f
_gadget0:
	call _type_value
	jp _debounce_loop
_off:
	halt
_clear_input:
	exx
	ld bc,0
	ld d,0
	exx
	jp _debounce_loop
_set_addr:
	exx
	ld h,b
	ld l,c
	ld bc,0
	ld d,0
	exx
	jp _debounce_loop
_write_value:
	exx
	push hl
	push bc
	ld bc,0
	ld d,0
	inc hl
	exx
	pop bc
	pop hl
	ld (hl),b
	jp _debounce_loop
_user_defined:
	jp _debounce_loop
_go:
	exx
	push bc
	exx
	ret
	jp _debounce_loop
_addr_dec:
	exx
	dec hl
	exx
	jp _debounce_loop
_addr_inc:
	exx
	inc hl
	exx
	jp _debounce_loop
_debounce_loop:;Implements button debouncing in software instead of software for further cost reduction.
	ld hl,$2000;Will depend based on clock speed. We want to enable holding buttons for repeating actions, but we also don't want to piss away everyone's time.
_debounce_loop1:
	dec hl
	ld a,h
	cp 0
	jr nz,_debounce_loop1
	ld a,l
	cp 0
	jr nz,_debounce_loop1
	jp _main

_print_buffer:
	ld a,0
	ld (iy+4),a
	ld (iy+5),a
	ld (iy+6),a
	ld (iy+7),a
	exx
	push de;Buffer index
	push bc;Buffer
	exx
	pop de;Buffer
	pop bc;Buffer index
	ld a,b
	cp 3
	jr z,_digit3
	cp 2
	jr z,_digit2
	cp 1
	jr z,_digit1
_digit4:
	ld a,e
	call _gadget2
	ld (iy+7),a
_digit3:
	ld a,e
	call _gadget1
	ld (iy+6),a
_digit2:
	ld a,d
	call _gadget2
	ld (iy+5),a
_digit1:
	ld a,d
	call _gadget1
	ld (iy+4),a
	jp _keypad_scan
		
_gadget1:;Continuing to make things smaller...
	srl a
	srl a
	srl a
	srl a
_hex_to_font:
	ld hl,_font
	ld b,0
	ld c,a
	add hl,bc
	ld a,(hl)
	ret

_gadget2:
	and %00001111
	jr _hex_to_font


_diagnostics:
	ld a,%01111010;d
	out ($00),a
	ld a,%00001000;i
	out ($01),a
	ld a,%11101110;A
	out ($02),a
	ld a,%10111100;G
	out ($03),a
	in a,($0b)
	and %00111111
	cp %00011111;[GO]
	jr nz,_diagnostics
	ld hl,$2000
;screen test
_diagSCREEN:
	dec hl
	ld a,h
	cp 0
	jr nz,_diagSCREEN
	ld a,l
	cp 0
	jr nz,_diagSCREEN
_diagSCREEN0:
	ld d,%11111111
	ld hl,_diagSCREEN1
	jp _diagSCREEN_sub
_diagSCREEN1:
	ld d,%00000000
	ld hl,_diagSCREEN2
	jp _diagSCREEN_sub
_diagSCREEN2:
	ld d,%10101010
	ld hl,_diagSCREEN3
	jp _diagSCREEN_sub
_diagSCREEN3:
	ld d,%01010101
	ld hl,_diagBUZZER
	jp _diagSCREEN_sub

;Buzzer test
_diagBUZZER:
	ld a,$80
_diagBUZZER1:
	dec a
	cp 0
	jr nz,_diagBUZZER1
	out ($0C),a
	in a,($0b)
	and %00111111
	cp %00011111;[GO]
	jr nz,_diagBUZZER
	ld hl,$2000
_diagBUZZER11:
	dec hl
	ld a,h
	cp 0
	jr nz,_diagBUZZER11
	ld a,l
	cp 0
	jr nz,_diagBUZZER11
;Keypad test
_stage0:
	ld d,0
        ld e,%11111100;0
        ld c,$08;io port (column select)
	ld b,%00011111;input read
	ld hl,_stage1
	jp _keycheck
_stage1:
        ld e,%01100000;1
	ld b,%00101111;input read
	ld hl,_stage4
	jp _keycheck 
_stage4:
        ld e,%01100110;4
	ld b,%00110111;input read
	ld hl,_stage7
	jp _keycheck 
_stage7:
        ld e,%11100000;7
	ld b,%00111011;input read
	ld hl,_stageA
	jp _keycheck
_stageA:
        ld e,%11101110;A
	ld b,%00111101;input read
	ld hl,_stageD
	jp _keycheck
_stageD:
        ld e,%01111010;d
	ld b,%00111110;input read
	ld hl,_stageAm
	jp _keycheck


_stageAm:
        ld d,%11101110;A
        ld e,%00000010;-
	ld c,$09
	ld b,%00011111
	ld hl,_stage2
	jp _keycheck         
_stage2:
	ld d,0
        ld e,%11011010;2
	ld b,%00101111;Input read
        ld hl,_stage5
	jp _keycheck
_stage5:
        ld e,%10110110;5
       	ld b,%00110111;Input read
        ld hl,_stage8
	jp _keycheck
_stage8:
        ld e,%11111110;8
 	ld b,%00111011;Input read
        ld hl,_stageB
	jp _keycheck
_stageB:
        ld e,%00111110;b
	ld b,%00111101;Input read
        ld hl,_stageE
	jp _keycheck
_stageE:
        ld e,%10011110;E
	ld b,%00111110;Input read
        ld hl,_stageAp
	jp _keycheck


_stageAp:
        ld d,%11101110;A
        ld e,%11001110;P
	ld c,$0A
	ld b,%00011111
	ld hl,_stage3
	jp _keycheck
_stage3:
        ld e,%11110010;2
	ld d,0
	ld b,%00101111;Input read
        ld hl,_stage6
	jp _keycheck
_stage6:
        ld e,%10111110;6
	ld b,%00110111;Input read
        ld hl,_stage9
	jp _keycheck
_stage9:
        ld e,%11110110;9
	ld b,%00111011;Input read
        ld hl,_stageC
	jp _keycheck
_stageC:
        ld e,%10011100;C
	ld b,%00111101;Input read
        ld hl,_stageF
	jp _keycheck
_stageF:
        ld e,%10001110;F
	ld b,%00111110;Input read
        ld hl,_stageGO
	jp _keycheck

_stageGO:
        ld d,%10111100;G
        ld e,%11111100;O
	ld c,$0B
	ld b,%00011111
	ld hl,_stageQ
	jp _keycheck
_stageQ:
        ld e,%11111101;""""Q""""
	ld d,0
	ld b,%00101111
	ld hl,_stageWR
	jp _keycheck 
_stageWR:
        ld d,%01111110;""""W""""
        ld e,%00001010;r
	ld b,%00110111
	ld hl,_stageRD
	jp _keycheck 
_stageRD:
        ld d,%00001010;r
        ld e,%01111010;d
        ld b,%00111011
	ld hl,_stageCE
	jp _keycheck
_stageCE:
        ld d,%10011100;C
        ld e,%10011110;E
        ld b,%00111101
	ld hl,_stageOFF
	jp _keycheck
_stageOFF:
        ld a,%11111100;O
        out ($05),a
        ld a,%10001110;F
        out ($06),a
        ld a,%10001110;F
        out ($07),a
        in a,($0B);keypad column 3
        and %00111111;Mask out pins used for general purpose input.
        cp %00111110;[GO]
        jp nz,_stageOFF

;RAM test
_ram_test:
        ld hl,$FFFF;Base RAM: $E000-$FFFF
        ld b,0
_all_zero:
	ld b,0
	ld ix,_all_zero_check
	jp _ram_write_loop
_all_zero_check:
	;ld b,0
	ld ix,_all_one
	jp _ram_read_loop
_all_one:
	ld b,$FF
	ld ix,_all_one_check
	jp _ram_write_loop
_all_one_check:
	;ld b,$FF
	ld ix,_all_pattern_0
	jp _ram_read_loop
_all_pattern_0:
	ld b,%10101010
	ld ix,_all_pattern_0_check
	jp _ram_write_loop
_all_pattern_0_check:
	;ld b,%10101010
	ld ix,_all_pattern_1
	jp _ram_read_loop
_all_pattern_1:
	ld b,%01010101
        ld ix,_all_pattern_1_check
	jp _ram_write_loop
        ld hl,$FFFF
_all_pattern_1_check:
        ;ld b,%01010101
	ld ix,_pass
	jp _ram_read_loop

_pass:
        ld a,%00001010;r
        out ($00),a
        ld a,%11001110;P
        out ($04),a
        ld a,%11101110;A
        out ($05),a
        ld a,%10110110;S
        out ($06),a
        ld a,%10110110;S
        out ($07),a
        jr _pass
_fail:
        ld a,%00001010;r
        out ($00),a
        ld a,%10001110;F
        out ($04),a
        ld a,%11101110;A
        out ($05),a
        ld a,%00001000;i
        out ($06),a
        ld a,%00011100;L
        out ($07),a
        jr _fail

_ram_write_loop:
	ld (hl),b
	dec hl
	ld a,h
	cp $df
	jr nz,_ram_write_loop
	ld a,l
	cp $ff
	jr nz,_ram_write_loop
	ld hl,$ffff
	jp (ix)
_ram_read_loop:
	ld a,(hl)
        cp b
        jp nz,_fail
        dec hl
        ld a,h
        cp $df
        jr nz,_ram_read_loop
        ld a,l
        cp $ff
        jr nz,_ram_read_loop
        ld hl,$FFFF;Base RAM: $E000-$FFFF
	jp (ix)
_keycheck:
        ld a,d
        out ($06),a
        ld a,e
        out ($07),a
        in a,(c);Select Keypad Column
        and %00111111;Mask out pins used for general purpose input.
        cp b;[GO]
        jp nz,_keycheck
	jp (hl)
_diagSCREEN_sub:
	ld a,d
	out ($00),a
	out ($01),a
	out ($02),a
	out ($03),a
	out ($04),a
	out ($05),a
	out ($06),a
	out ($07),a
	in a,($0b)
	and %00111111
	cp %00011111;[GO]
	jr nz,_diagSCREEN_sub
	ld bc,$2000
_diagSCREEN_sub1:
	dec bc
	ld a,b
	cp 0
	jr nz,_diagSCREEN_sub1
	ld a,c
	cp 0
	jr nz,_diagSCREEN_sub1
	jp (hl)



_font:
db %11111100;0
db %01100000;1
db %11011010;2
db %11110010;3
db %01100110;4
db %10110110;5
db %10111110;6
db %11100000;7
db %11111110;8
db %11110110;9
db %11101110;A
db %00111110;b
db %10011100;C
db %01111010;d
db %10011110;E
db %10001110;F
db %00000001;decimal point

_cart_header:;Used to detect if a cartridge containing QK-1 code is inserted.
db $e2
db $9a
db $a7
db $0a
